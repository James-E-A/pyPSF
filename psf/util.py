#!/usr/bin/env python3
from .psf import Psf,CP437_Names
from PIL import Image
import os,os.path
import sys
import argparse

def psf2dir_entrypoint(*argv):
	I={
	  'prog':           'psf2dir',
	  'description':    "Extract a .psf file into a folder of images"
	}
	A={
	  'psf_path':{
		'metavar':  "psf",
		'help':     "Location of the .psf file to be extracted"},
	  'output_dir':{
		'metavar':  "folder",
		'nargs':    '?',
		'help':     "Manually specify a folder name"},
	  '-f|--clobber':{
		'action':   'store_true',
		'dest':     'clobberdir',
		'help':     "Continue anyway if folder exists"}
	}
	return _e(I,A,argv)

def dir2psf_entrypoint(*argv):
	I={
	  'prog':           'dir2psf',
	  'description':    "Compile a folder of images generated by psf2dir back into a .psf file"
	}
	A={
	  'dir_path':{
		'metavar':  "folder",
		'help':     "Input folder of images"},
	  'psf_path':{
		'metavar':  "psf",
		'help':     "Location of the .psf file (WILL BE OVERWRITTEN)"},
	}
	return _e(I,A,argv)

def psf2dir(psf_path, output_dir=None, clobberdir=False, ext='png'):
	p=Psf(psf_path)
	if output_dir is None:
		output_dir=os.path.splitext(psf_path)[0]
	try:
		os.mkdir(output_dir)
	except FileExistsError:
		if not clobberdir:
			raise
	os.chdir(output_dir)
	
	for i in range(len(p.glyphs)):
		if i<256:
			n=CP437_Names[i].replace('/','-').replace(' ','_')
			s="0x{:02X}_{}.{}"
			name=s.format(i,n,ext)
		else:
			s="EXT_0x{:04X}.{}"
			name=s.format(i,ext)
		Image.frombytes('1',p.size,p.glyphs[i]).save(name)

def dir2psf(dir_path, psf_path=None, clobberpsf=True, ext="png"):
	raise NotImplementedError

############################
## "UGLY" CODE BELOW HERE ##
## PLS GO AWAY            ##
##        DO NOT QUESTION ##
##    THE MAGIC FUNCTIONS ##
############################

def __main__(*argv):
	arg0=os.path.splitext(argv[0])[0]
	if arg0.endswith('psf2dir'):
		return psf2dir_entrypoint(*argv)
	elif arg0.endswith('dir2psf'):
		return dir2psf_entrypoint(*argv)

_fix_None=lambda A,a=sys.argv: A if A else (*a[1:],)

def _argparse_dict2XXkwarg(metad,d,argv=sys.argv):
	P=argparse.ArgumentParser(**metad)
	for k,v in d.items():
		P.add_argument(*k.split('|'),**v)
	return vars(P.parse_args())

def _e(md,ad,argv):
	return globals()[md['prog']](**_argparse_dict2XXkwarg(md,ad,_fix_None(argv)))

if __name__=="__main__":
	sys.exit(__main__(*sys.argv))
